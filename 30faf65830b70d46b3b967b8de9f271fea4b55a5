{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "216cfee2_49d61a23",
        "filename": "re2/prefilter.cc",
        "patchSetId": 1
      },
      "lineNbr": 345,
      "author": {
        "id": 44657
      },
      "writtenOn": "2022-10-07T14:14:20Z",
      "side": 1,
      "message": "There is a subtle difference in logic between the previous code and this version. \n\nIn the earlier version, content of a-\u003eexact_ and b-\u003eexact_ was copied (set-unioned) into ab-\u003eexact_. \n\nIn this version, ab-\u003eexact_ \u003d a-\u003eexact_ UNION b-\u003eexact_.\n\nThe difference being that any pre-existing values in ab-\u003eexact_ (that may be defined by the constructor of Info()) will get lost in the second version.\n\nNow looking at the Info class, it doesn\u0027t seem possible right now, but we don\u0027t know how this file is touched or evolves in the future.\n\nI was thinking of the following two options:\n1. simply do ab-\u003eexact_.insert(a) and ab-\u003eexact_.insert(b), keeping the current behavior intact.\n2. overload the constructor of Info to take two sets, whose union it stores in exact_. Then, we simply call Info *ab \u003d Info(a-\u003eexact_, b-\u003eexact_). \nDoing so will ensure anyone in future changing the constructor to set any pre-existing value in exact_ does not need to worry about the code here.\n\n2 can follow 1 in a separate CL as well. ðŸ˜Š",
      "range": {
        "startLine": 345,
        "startChar": 4,
        "endLine": 345,
        "endChar": 14
      },
      "revId": "30faf65830b70d46b3b967b8de9f271fea4b55a5",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bf59ae1d_cd9354d5",
        "filename": "re2/prefilter.cc",
        "patchSetId": 1
      },
      "lineNbr": 345,
      "author": {
        "id": 44657
      },
      "writtenOn": "2022-10-07T14:37:57Z",
      "side": 1,
      "message": "Spoke too soon.\nReading more about it, 1 doesn\u0027t help at all, since the contents of a set are const.\n\nConsider doing 2 to provide a safer interface (unless re2 maintainers are okay with this design as well).\n\nC++17 merge would have been super useful indeed. Can\u0027t we do something like:\nif C++17 do X else do Y? :P",
      "parentUuid": "216cfee2_49d61a23",
      "range": {
        "startLine": 345,
        "startChar": 4,
        "endLine": 345,
        "endChar": 14
      },
      "revId": "30faf65830b70d46b3b967b8de9f271fea4b55a5",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3de48efe_ebf0a69f",
        "filename": "re2/prefilter.cc",
        "patchSetId": 1
      },
      "lineNbr": 345,
      "author": {
        "id": 44652
      },
      "writtenOn": "2022-10-07T14:57:15Z",
      "side": 1,
      "message": "I\u0027m not the steward obviously, but I\u0027m going to advise against 2.\n\n`Alt` is a static factory \"constructor\" for this class, and documented as such on \nline 209. There are 13 other functions that do similar work, and make similar assumptions about the state of a new Info(). \n\nIf we had a magic wand, I agree that traditional constructors may be useful, however, we get nearly all the performance improvements with these few lines. \n\nI think what you\u0027re recommending would be a cleaner C++ implementation. However, I\u0027d expect the entirety of this class\u0027s factory functions to be moved over, to keep it consistent with other functions like `Quest`. I\u0027m not seeing the ROI on that.\n\n---\n\nC++17 would be useful. If I were the owner, I probably wouldn\u0027t want this to be the first place that someone introduces a `#ifdef cpp17`, but if that mechanism already exists elsewhere, I\u0027d be happy to update it.\n\nIn practice? It\u0027s probably not a huge win in our production workload. In tests on my end, I was seeing calls to `Alt` like:\n\n```\n|a.exact| \u003d 1, |b.exact| \u003d 0. Copy 1 strings into ab. Copy 0 string into ab.\n \nDestroy |a|, destroy |b| (2 string destructors called)\n\n... \u003c15k iterations later\u003e\n\n|a.exact| \u003d 15k. |b.exact| \u003d 1. Copy 15k strings into ab. Copy 1 string into ab. \n\nDestroy |a|, destroy |b|, (15001 string desctructors called)\n```\n\nWith this version:\n\n```\n|a.exact| \u003d 15k, |b.exact| \u003d 1. Move 15k in O(1), copy 1 string, destroy 1 string.\n```\n\nWe\u0027re *still* destroying 15k strings when we could just be potentially saving them. That being said, the move saves the lion share of the work. If cpp17 is a no-go, I\u0027m not hung up on it.",
      "parentUuid": "216cfee2_49d61a23",
      "range": {
        "startLine": 345,
        "startChar": 4,
        "endLine": 345,
        "endChar": 14
      },
      "revId": "30faf65830b70d46b3b967b8de9f271fea4b55a5",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1b01e30d_c1f0b234",
        "filename": "re2/prefilter.cc",
        "patchSetId": 1
      },
      "lineNbr": 345,
      "author": {
        "id": 44657
      },
      "writtenOn": "2022-10-07T16:00:02Z",
      "side": 1,
      "message": "Ah! That makes sense.\nThanks for the detailed description.\n\nI saw a few compiler based #ifdefs in re2, but non specifically for C++17.\n\nKeeping this as resolved.",
      "parentUuid": "3de48efe_ebf0a69f",
      "range": {
        "startLine": 345,
        "startChar": 4,
        "endLine": 345,
        "endChar": 14
      },
      "revId": "30faf65830b70d46b3b967b8de9f271fea4b55a5",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa"
    }
  ]
}